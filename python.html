<!DOCTYPE html>
<html>

<head>
    <title>Python</title>
    <link href="assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
</head>

<body style="font-family: Georgia, 'Times New Roman', Times, serif;">
    <h2 style="text-align: center;">Python Topics and Concepts!!!</h2><br />
    <div class="container">
        <p>
        <h5>Here are some of the main topics in Python programming: </h5>
        <ol>
            <li>
                <p><strong>Basic Syntax and Data Types:</strong> Variables, data types (integers, floats, strings),
                    operators, basic input/output.</p>
            </li>
            <li>
                <p><strong>Control Structures:</strong> Conditional statements (if, elif, else), loops (for, while),
                    break and continue statements.</p>
            </li>
            <li>
                <p><strong>Functions:</strong> Defining and using functions, parameters, return values, scope. </p>
            </li>
            <li>
                <p><strong>Data Structures:</strong> Lists, tuples, sets, dictionaries, manipulating and accessing
                    elements.</p>
            </li>
            <li>
                <p><strong>String Manipulation:</strong> String methods, formatting, slicing. </p>
            </li>
            <li>
                <p><strong>File Handling:</strong> Reading and writing files, file modes, working with CSV and JSON
                    files.</p>
            </li>
            <li>
                <p><strong>Exception Handling:</strong> Try, except, finally blocks for handling errors and exceptions.
                </p>
            </li>
            <li>
                <p><strong>Object-Oriented Programming (OOP):</strong> Classes, objects, constructors, inheritance,
                    encapsulation, polymorphism. </p>
            </li>
            <li>
                <p><strong>Modules and Packages:</strong> Importing modules, creating and using packages, namespaces.
                </p>
            </li>
            <li>
                <p><strong>Regular Expressions:</strong> Pattern matching using regular expressions. </p>
            </li>
            <li>
                <p><strong>Advanced Data Structures:</strong> Stacks, queues, linked lists, trees, graphs. </p>
            </li>
            <li>
                <p><strong>Advanced Topics:</strong> Decorators, generators, iterators, context managers.</p>
            </li>
            <li>
                <p><strong>Built-in Functions and Libraries:</strong> Commonly used functions (len, range, map, etc.),
                    standard libraries (math, datetime, os, etc.). </p>
            </li>
            <li>
                <p><strong>Working with APIs:</strong> Making HTTP requests, handling JSON responses. </p>
            </li>
            <li>
                <p><strong>Database Interaction:</strong> Basics of connecting to and interacting with databases. </p>
            </li>
            <li>
                <p><strong>Unit Testing:</strong> Writing and running test cases using the `unittest` framework. </p>
            </li>
            <li>
                <p><strong>Virtual Environments:</strong> Managing dependencies and isolated environments using
                    `virtualenv` or `venv`.</p>
            </li>
            <li>
                <p><strong>Debugging and Profiling:</strong> Techniques for finding and fixing code issues, optimizing
                    performance.</p>
            </li>
            <li>
                <p><strong>Web Development:</strong> Basics of web frameworks like Flask or Django. </p>
            </li>
            <li>
                <p><strong>GUI Programming:</strong> Creating graphical user interfaces using libraries like Tkinter or
                    PyQt.</p>
            </li>
            <li>
                <p><strong>Concurrency and Threading:</strong> Multithreading and multiprocessing for concurrent
                    execution.</p>
            </li>
            <li>
                <p><strong>Networking:</strong> Sockets, sending and receiving data over networks. </p>
            </li>
            <li>
                <p><strong>Data Science and Analysis:</strong> Libraries like NumPy, Pandas, and Matplotlib for data
                    manipulation and visualization. </p>
            </li>
            <li>
                <p><strong>Machine Learning and AI:</strong> Libraries like Scikit-Learn, TensorFlow, and PyTorch for
                    machine learning and artificial intelligence. </p>
            </li>
            <li>
                <p><strong>Web Scraping:</strong> Extracting data from websites using libraries like Beautiful Soup and
                    Requests.</p>
            </li>
        </ol>
        </p>
        <p>
        <h4>Basic Syntax and Data Types in Python</h4>
        <ol>
            <li>
                <p><strong>Variables</strong>: Used to store data. No need to declare a
                    variable's type explicitly.</p>
            </li>
            <li>
                <p><strong>Data Types</strong>: Python has various built-in data types:</p>
                <ul>
                    <li><strong>Integers</strong>: Whole numbers.</li>
                    <li><strong>Floats</strong>: Numbers with decimal points.</li>
                    <li><strong>Strings</strong>: Sequences of characters.</li>
                    <li><strong>Boolean</strong>: Represents True or False.</li>
                </ul>
            </li>
            <li>
                <p><strong>Operators</strong>: Used to perform operations on variables and
                    values.</p>
                <ul>
                    <li><strong>Arithmetic Operators</strong>: +, -, *, /, %, // (floor
                        division), ** (exponentiation).</li>
                    <li><strong>Comparison Operators</strong>: ==, !=, &lt;, &gt;, &lt;=, &gt;=.
                    </li>
                    <li><strong>Logical Operators</strong>: and, or, not.</li>
                </ul>
            </li>
            <li>
                <p><strong>Basic Input/Output</strong>: Using <code>input()</code> to get user
                    input and <code>print()</code> to display output.</p>
            </li>
            <li>
                <p><strong>Comments</strong>: Lines beginning with <code>#</code> are comments
                    and are ignored by the interpreter.</p>
            </li>
        </ol>
        <p>Here's a simple example of Python code that demonstrates these concepts:</p>
        <pre>
                <div class="bg-black rounded-md mb-4">
                    <code class="!whitespace-pre hljs language-python">
                        <span class="hljs-comment"># This is a comment</span>
                        num1 = <span class="hljs-number">10</span>           <span class="hljs-comment"># An integer variable</span>
                        num2 = <span class="hljs-number">3.14</span>         <span class="hljs-comment"># A float variable</span>
                        name = <span class="hljs-string">"John"</span>       <span class="hljs-comment"># A string variable</span>
                        is_student = <span class="hljs-literal">True</span>   <span class="hljs-comment"># A boolean variable</span>
                        <span class="hljs-comment"># Arithmetic operations</span>
                        sum_result = num1 + num2
                        product_result = num1 * num2
                        <span class="hljs-comment"># Displaying output</span>
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello,"</span>, name)
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Sum:"</span>, sum_result)
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Product:"</span>, product_result)
                        <span class="hljs-comment"># Getting user input</span>
                        age = <span class="hljs-built_in">input</span>(<span class="hljs-string">"Enter your age: "</span>)
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">"You are"</span>, age, <span class="hljs-string">"years old."</span>)
                    </code>
                </div>
            </pre>
        </p>
        <p>
        <h1>Control Structures in Python</h1>
        <p>Control structures in Python allow you to control the flow of your program. Here are the main control
            structures:</p>

        <h2>1. Conditional Statements (if, elif, else)</h2>
        <p>Used to execute different code blocks based on conditions.</p>
        <pre><code>if condition1:
    # Code to execute if condition1 is True
elif condition2:
    # Code to execute if condition2 is True
else:
    # Code to execute if none of the conditions are True</code></pre>

        <h2>2. Loops (for, while)</h2>
        <p>Used to execute a block of code repeatedly.</p>
        <h3>For Loop</h3>
        <p>Iterates over a sequence (list, tuple, string, etc.).</p>
        <pre><code>for item in sequence:
    # Code to execute for each item in the sequence</code></pre>

        <h3>While Loop</h3>
        <p>Executes a block of code as long as a condition is True.</p>
        <pre><code>while condition:
    # Code to execute while the condition is True</code></pre>

        <h2>3. Break and Continue Statements</h2>
        <p>Used to modify the flow of loops.</p>
        <h3>Break</h3>
        <p>Exits the loop prematurely.</p>
        <pre><code>for item in sequence:
    if condition:
        break</code></pre>

        <h3>Continue</h3>
        <p>Skips the current iteration and moves to the next.</p>
        <pre><code>for item in sequence:
    if condition:
        continue</code></pre>

        <p>Here's an example demonstrating these control structures:</p>
        <pre><code># Conditional Statements
x = 10
if x > 0:
    print("x is positive")
elif x == 0:
    print("x is zero")
else:
    print("x is negative")

# For Loop
numbers = [1, 2, 3, 4, 5]
sum = 0
for num in numbers:
    sum += num
print("Sum:", sum)

# While Loop
count = 0
while count < 5:
    print("Count:", count)
    count += 1

# Break and Continue
for i in range(10):
    if i == 3:
        break
    if i % 2 == 0:
        continue
    print(i)</code></pre>

        <p>Control structures help you create more dynamic and responsive programs by allowing you to make decisions and
            repeat actions as needed.</p>
        </p>


        <h1>Functions in Python</h1>
        <p>Functions in Python are reusable blocks of code that perform specific tasks. They help organize code, make it
            more modular, and reduce redundancy. Here's how to work with functions:</p>

        <h2>1. Defining a Function</h2>
        <p>To define a function, use the <code>def</code> keyword followed by the function name and parameters within
            parentheses. The function body is indented below.</p>
        <pre><code>def greet(name):
    print("Hello, " + name)</code></pre>

        <h2>2. Calling a Function</h2>
        <p>To use a function, call it by its name and provide arguments if needed.</p>
        <pre><code>greet("Alice")</code></pre>

        <h2>3. Parameters and Arguments</h2>
        <p>Parameters are variables in a function's definition. Arguments are values passed to a function when it's
            called.</p>
        <pre><code>def add(a, b):
    return a + b
    
result = add(3, 5)  # Here, 3 and 5 are arguments</code></pre>

        <h2>4. Return Statement</h2>
        <p>Functions can return values using the <code>return</code> statement. If no return value is specified, the
            function returns <code>None</code>.</p>
        <pre><code>def square(x):
    return x * x
    
squared_value = square(4)</code></pre>

        <h2>5. Default Arguments</h2>
        <p>You can provide default values for function parameters, which are used when the caller doesn't provide a
            value for that parameter.</p>
        <pre><code>def power(base, exponent=2):
    return base ** exponent
    
result1 = power(3)      # Uses default exponent of 2
result2 = power(2, 3)   # Uses provided exponent of 3</code></pre>

        <h2>6. Variable Number of Arguments</h2>
        <p>Functions can accept a variable number of arguments using <code>*args</code> for positional arguments and
            <code>**kwargs</code> for keyword arguments.</p>
        <pre><code>def print_args(*args):
    for arg in args:
        print(arg)
    
print_args(1, 2, 3)</code></pre>

        <h2>7. Scope</h2>
        <p>Variables defined inside a function are in its local scope. Variables defined outside functions are in the
            global scope.</p>
        <pre><code>global_var = 10  // Global variable
    
def demo_scope():
    local_var = 5  // Local variable
    print(global_var)
    print(local_var)
    
demo_scope()</code></pre>

        <p>Functions are a fundamental building block of Python programming, allowing you to create more organized,
            reusable, and maintainable code.</p>
        <h1>Built-In Data Structures in Python</h1>
        <p>Python offers several built-in data structures that help you organize and manipulate data efficiently. Here
            are some of the main data structures:</p>

        <h2>1. Lists</h2>
        <p>Ordered, mutable collections of items.</p>
        <pre><code>my_list = [1, 2, 3, 4]
my_list.append(5)
my_list.pop(2)</code></pre>

        <h2>2. Tuples</h2>
        <p>Ordered, immutable collections of items.</p>
        <pre><code>my_tuple = (1, 2, 3)
value = my_tuple[1]</code></pre>

        <h2>3. Sets</h2>
        <p>Unordered collections of unique items.</p>
        <pre><code>my_set = {1, 2, 3}
my_set.add(4)
my_set.remove(2)</code></pre>

        <h2>4. Dictionaries</h2>
        <p>Unordered collections of key-value pairs.</p>
        <pre><code>my_dict = {'name': 'Alice', 'age': 25}
my_dict['city'] = 'New York'
age = my_dict['age']</code></pre>

        <h2>5. Strings</h2>
        <p>Sequences of characters.</p>
        <pre><code>my_string = "Hello, Python"
substring = my_string[7:13]</code></pre>

        <h2>6. Lists of Lists (Nested Lists)</h2>
        <p>Creating lists that contain other lists.</p>
        <pre><code>matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
value = matrix[1][2]</code></pre>

        <h2>7. List Comprehensions</h2>
        <p>Creating lists using a compact syntax.</p>
        <pre><code>squares = [x ** 2 for x in range(1, 6)]</code></pre>

        <h2>8. Dictionaries of Dictionaries (Nested Dictionaries)</h2>
        <p>Creating dictionaries that contain other dictionaries.</p>
        <pre><code>users = {
    'user1': {'name': 'Alice', 'age': 25},
    'user2': {'name': 'Bob', 'age': 30}
}
age = users['user1']['age']</code></pre>

        <h2>9. Sets and Frozensets</h2>
        <p>Sets are mutable, while frozensets are immutable sets.</p>
        <pre><code>my_set = {1, 2, 3}
my_frozenset = frozenset(my_set)</code></pre>

        <h2>10. Deque</h2>
        <p>Double-ended queue for efficient insertion and deletion from both ends.</p>
        <pre><code>&lt;!-- Make sure to include the Python code --&gt;</code></pre>

        <p>These data structures provide different ways to store and manipulate data, making Python versatile for a wide
            range of programming tasks.</p>
        <h1>String Manipulation in Python</h1>
        <p>String manipulation in Python involves various operations to work with and manipulate strings. Here are some
            common string manipulation techniques:</p>

        <h2>1. Concatenation</h2>
        <p>Combining strings together.</p>
        <pre><code>str1 = "Hello"
str2 = "World"
result = str1 + " " + str2</code></pre>

        <h2>2. String Formatting</h2>
        <p>Creating formatted strings using placeholders.</p>
        <pre><code>name = "Alice"
age = 30
message = "My name is {} and I am {} years old.".format(name, age)</code></pre>

        <h2>3. String Methods</h2>
        <p>Python provides a wide range of string methods for various operations.</p>
        <pre><code>my_string = "Hello, Python!"
length = len(my_string)
uppercase = my_string.upper()
lowercase = my_string.lower()</code></pre>

        <h2>4. String Slicing</h2>
        <p>Extracting portions of a string.</p>
        <pre><code>my_string = "Hello, Python!"
substring = my_string[7:13]  // Extracts "Python"</code></pre>

        <h2>5. String Splitting and Joining</h2>
        <pre><code>my_string = "apple,banana,orange"
fruits_list = my_string.split(",")

fruits = ["apple", "banana", "orange"]
joined_string = "-".join(fruits)</code></pre>

        <h2>6. Stripping Whitespaces</h2>
        <pre><code>my_string = "   Hello, Python!   "
stripped_string = my_string.strip()  // Removes leading and trailing whitespaces</code></pre>

        <h2>7. Replacing Substrings</h2>
        <pre><code>my_string = "Hello, World!"
new_string = my_string.replace("World", "Python")</code></pre>

        <h2>8. Checking Substrings</h2>
        <pre><code>my_string = "Hello, Python!"
contains_python = "Python" in my_string</code></pre>

        <h2>9. String Formatting (f-strings) (Python 3.6+)</h2>
        <pre><code>name = "Alice"
age = 30
message = f"My name is {name} and I am {age} years old."</code></pre>

        <p>String manipulation is essential for working with textual data and is used extensively in applications
            ranging from data processing to web development.</p>
        <h1>File Handling in Python</h1>
        <p>File handling in Python allows you to work with files, both for reading and writing data. Here's how you can
            use file handling operations:</p>

        <h2>1. Opening a File</h2>
        <p>To work with a file, you need to open it using the <code>open()</code> function. You specify the file name
            and the mode in which you want to open the file (read, write, or both).</p>
        <pre><code># Opening a file for reading
file = open("example.txt", "r")

# Opening a file for writing
file = open("output.txt", "w")</code></pre>

        <h2>2. Reading from a File</h2>
        <p>You can read the contents of a file using methods like <code>read()</code>, <code>readline()</code>, or
            <code>readlines()</code>.</p>
        <pre><code># Reading the entire content
content = file.read()

# Reading one line
line = file.readline()

# Reading all lines into a list
lines = file.readlines()</code></pre>

        <h2>3. Writing to a File</h2>
        <p>You can write to a file using methods like <code>write()</code>.</p>
        <pre><code># Writing a string to the file
file.write("Hello, world!")</code></pre>

        <h2>4. Closing a File</h2>
        <p>It's important to close the file after you're done working with it to free up system resources.</p>
        <pre><code>file.close()</code></pre>

        <h2>5. Using 'with' Statement (Context Manager)</h2>
        <p>The <code>with</code> statement ensures that the file is properly closed after you're done, even if an
            exception occurs.</p>
        <pre><code>with open("example.txt", "r") as file:
    content = file.read()</code></pre>

        <h2>6. Appending to a File</h2>
        <p>To add content to an existing file without overwriting it, you can open the file in append mode ("a").</p>
        <pre><code>with open("output.txt", "a") as file:
    file.write("Additional content")</code></pre>

        <p>File handling is a fundamental aspect of programming for tasks involving data storage, retrieval, and
            manipulation. Always make sure to properly close the file after you're done with it to avoid resource leaks.
        </p>
        <h1>Exception Handling in Python</h1>
        <p>Exception handling in Python allows you to handle errors and exceptions gracefully, preventing your program
            from crashing. Here's how you can use exception handling:</p>

        <h2>1. Try-Except Block</h2>
        <p>Use a <code>try</code> block to enclose the code that might raise an exception. If an exception occurs, the
            code in the corresponding <code>except</code> block will be executed.</p>
        <pre><code>try:
    # Code that might raise an exception
    result = 10 / 0
except ZeroDivisionError:
    # Code to handle the exception
    print("Division by zero error")</code></pre>

        <h2>2. Multiple Except Blocks</h2>
        <p>You can handle different types of exceptions with multiple <code>except</code> blocks.</p>
        <pre><code>try:
    value = int("abc")
except ValueError:
    print("ValueError occurred")
except ZeroDivisionError:
    print("ZeroDivisionError occurred")</code></pre>

        <h2>3. Exception with an Else Block</h2>
        <p>You can use an <code>else</code> block to execute code when no exception occurs.</p>
        <pre><code>try:
    x = 10 / 2
except ZeroDivisionError:
    print("Cannot divide by zero")
else:
    print("Result:", x)</code></pre>

        <h2>4. Exception with a Finally Block</h2>
        <p>The <code>finally</code> block always executes, whether an exception occurred or not. It's commonly used to
            release resources.</p>
        <pre><code>try:
    file = open("example.txt", "r")
    content = file.read()
except FileNotFoundError:
    print("File not found")
finally:
    file.close()</code></pre>

        <h2>5. Raising Exceptions</h2>
        <p>You can manually raise exceptions using the <code>raise</code> statement.</p>
        <pre><code>def divide(a, b):
    if b == 0:
        raise ZeroDivisionError("Division by zero is not allowed")
    return a / b</code></pre>

        <h2>6. Custom Exception Classes</h2>
        <p>You can define your own custom exception classes by subclassing built-in exceptions or the
            <code>Exception</code> class.</p>
        <pre><code>class CustomError(Exception):
    def __init__(self, message):
        self.message = message</code></pre>

        <p>Exception handling allows you to anticipate and handle errors, making your code more robust and
            user-friendly. It's crucial for creating reliable programs that can gracefully handle unexpected situations.
        </p>
        <h1>Object-Oriented Programming in Python</h1>
        <p>Object-Oriented Programming (OOP) is a programming paradigm that focuses on organizing code around objects,
            which are instances of classes. Python is an object-oriented language, and here's how you can work with OOP
            concepts:</p>

        <h2>1. Classes and Objects</h2>
        <p><strong>Class:</strong> A blueprint or template for creating objects. It defines attributes (data) and
            methods (functions) that the objects will have.</p>
        <pre><code>class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def greet(self):
        return f"Hello, my name is {self.name} and I am {self.age} years old."</code></pre>
        <p><strong>Object:</strong> An instance of a class with its own unique data and behavior.</p>
        <pre><code>person1 = Person("Alice", 30)
person2 = Person("Bob", 25)

print(person1.greet())  // Output: Hello, my name is Alice and I am 30 years old.</code></pre>

        <h2>2. Attributes and Methods</h2>
        <p><strong>Attributes:</strong> Variables that belong to an object and store its data.</p>
        <p><strong>Methods:</strong> Functions defined within a class that can be called on objects of that class.</p>

        <h2>3. Constructor (`__init__`)</h2>
        <p>The <code>__init__</code> method is used to initialize object attributes when an object is created.</p>
        <pre><code>def __init__(self, attribute1, attribute2):
    self.attribute1 = attribute1
    self.attribute2 = attribute2</code></pre>

        <h2>4. Inheritance</h2>
        <p>Inheritance allows a class (subclass/derived class) to inherit attributes and methods from another class
            (base class/superclass).</p>
        <pre><code>class Student(Person):
    def __init__(self, name, age, student_id):
        super().__init__(name, age)
        self.student_id = student_id</code></pre>

        <h2>5. Encapsulation</h2>
        <p>Encapsulation restricts direct access to certain attributes and methods, promoting data hiding and
            abstraction.</p>

        <h2>6. Polymorphism</h2>
        <p>Polymorphism allows objects of different classes to be treated as objects of a common superclass. It enables
            method overriding and dynamic method binding.</p>
        <pre><code>class Shape:
    def area(self):
        pass

class Circle(Shape):
    def area(self, radius):
        return 3.14 * radius ** 2

class Rectangle(Shape):
    def area(self, length, width):
        return length * width</code></pre>

        <h2>7. Abstraction</h2>
        <p>Abstraction focuses on providing a simplified interface for interacting with objects, hiding complex
            implementation details.</p>

        <p>OOP provides a structured and modular approach to programming, making code more organized, maintainable, and
            reusable. It models real-world concepts effectively and encourages better problem-solving through
            encapsulation and abstraction.</p>
        <h1>Modules and Packages in Python</h1>
        <p>Modules and packages are key concepts in Python that help organize code into reusable and manageable
            components. Here's how they work:</p>

        <h2>1. Modules</h2>
        <p>A module is a single Python file containing variables, functions, and classes that can be imported and used
            in other programs.</p>
        <p>Create a module by writing your code in a <code>.py</code> file, e.g., <code>my_module.py</code>.</p>
        <pre><code># my_module.py
def greet(name):
    return f"Hello, {name}!"

def add(a, b):
    return a + b</code></pre>
        <p>Import and use functions/classes from the module in another file.</p>
        <pre><code>import my_module

result = my_module.add(3, 5)
greeting = my_module.greet("Alice")</code></pre>

        <h2>2. Packages</h2>
        <p>A package is a collection of related modules organized in directories. It allows for a hierarchical structure
            to manage larger projects.</p>
        <p>Create a directory for your package and include an <code>__init__.py</code> file in it.</p>
        <pre><code>my_package/
    __init__.py
    module1.py
    module2.py</code></pre>
        <p>Import modules from the package using dot notation.</p>
        <pre><code>import my_package.module1
result = my_package.module1.add(3, 5)</code></pre>
        <p>You can also use the <code>from ... import ...</code> syntax.</p>
        <pre><code>from my_package import module2
greeting = module2.greet("Bob")</code></pre>

        <h2>3. <code>__init__.py</code></h2>
        <p>The <code>__init__.py</code> file in a package directory can be left empty or contain initialization code for
            the package.</p>

        <h2>4. Subpackages</h2>
        <p>Packages can have subpackages, allowing you to organize modules further.</p>
        <pre><code>my_package/
    __init__.py
    module1.py
    subpackage/
        __init__.py
        module3.py</code></pre>
        <pre><code>from my_package.subpackage import module3
result = module3.multiply(4, 6)</code></pre>

        <p>Modules and packages promote code reusability, maintainability, and separation of concerns. They are crucial
            for structuring larger projects and making code more organized and manageable.</p>
        <h1>Regular Expressions in Python</h1>
        <p>Regular expressions (regex) are powerful tools for pattern matching and manipulation of strings in Python.
            They allow you to search for, match, and manipulate text based on specific patterns. Here's how you can use
            regular expressions in Python:</p>

        <h2>1. Importing the <code>re</code> Module</h2>
        <p>To use regular expressions, you need to import the <code>re</code> module.</p>
        <pre><code>import re</code></pre>

        <h2>2. Basic Matching</h2>
        <p>You can use the <code>re.search()</code> function to find the first occurrence of a pattern in a string.</p>
        <pre><code>pattern = r"world"
text = "Hello, world!"
match = re.search(pattern, text)
if match:
    print("Pattern found:", match.group())</code></pre>

        <h2>3. Pattern Modifiers</h2>
        <ul>
            <li><code>r"`string`"</code>: Use raw strings to avoid escaping backslashes.</li>
            <li><code>re.I</code> (case-insensitive): Use <code>re.search(pattern, text, re.I)</code> to make the search
                case-insensitive.</li>
        </ul>

        <h2>4. Character Classes</h2>
        <ul>
            <li><code>[abc]</code>: Match any of the characters a, b, or c.</li>
            <li><code>[a-z]</code>: Match any lowercase letter.</li>
            <li><code>[0-9]</code>: Match any digit.</li>
        </ul>

        <h2>5. Special Characters</h2>
        <ul>
            <li><code>\d</code>: Match any digit (0-9).</li>
            <li><code>\w</code>: Match any alphanumeric character.</li>
            <li><code>\s</code>: Match any whitespace character.</li>
        </ul>

        <h2>6. Quantifiers</h2>
        <ul>
            <li><code>*</code>: Match zero or more occurrences.</li>
            <li><code>+</code>: Match one or more occurrences.</li>
            <li><code>?</code>: Match zero or one occurrence.</li>
            <li><code>{n}</code>: Match exactly n occurrences.</li>
            <li><code>{n, m}</code>: Match between n and m occurrences.</li>
        </ul>

        <h2>7. Anchors</h2>
        <ul>
            <li><code>^</code>: Match the start of a string.</li>
            <li><code>$</code>: Match the end of a string.</li>
        </ul>

        <h2>8. Groups and Capturing</h2>
        <p>Use parentheses to create capturing groups.</p>
        <pre><code>pattern = r"(\d{3})-(\d{2})"
text = "123-45"
match = re.search(pattern, text)
if match:
    area_code = match.group(1)
    local_code = match.group(2)</code></pre>

        <h2>9. Substitution</h2>
        <p>You can use <code>re.sub()</code> to replace matched patterns with other text.</p>
        <pre><code>pattern = r"\bapple\b"
text = "I like apple and pineapple."
new_text = re.sub(pattern, "orange", text)</code></pre>

        <p>Regular expressions provide a versatile way to work with text data, making it easier to perform complex
            searches and manipulations in strings. However, they can be complex, so practice and documentation are
            essential for mastering them.</p>
        <h1>Advanced Data Structures in Python</h1>
        <p>Python offers advanced data structures beyond the basic ones like lists, tuples, and dictionaries. Here are a
            few advanced data structures you might find useful:</p>

        <h2>1. Sets with Set Operations</h2>
        <p>Sets are collections of unique elements. Python's <code>set</code> class supports set operations like union,
            intersection, and difference.</p>
        <pre><code>set1 = {1, 2, 3}
set2 = {3, 4, 5}

union = set1 | set2
intersection = set1 & set2
difference = set1 - set2</code></pre>

        <h2>2. Defaultdict and Counter from Collections</h2>
        <p>The <code>collections</code> module offers useful data structures like <code>defaultdict</code> and
            <code>Counter</code>.</p>
        <ul>
            <li><code>defaultdict</code>: A dictionary that automatically creates default values for missing keys.</li>
            <pre><code>from collections import defaultdict

d = defaultdict(int)
d['a'] += 1</code></pre>
            <li><code>Counter</code>: A dictionary for counting hashable objects.</li>
            <pre><code>from collections import Counter

c = Counter(['a', 'b', 'a', 'c', 'b'])
most_common = c.most_common(2)</code></pre>
        </ul>

        <h2>3. OrderedDict</h2>
        <p><code>OrderedDict</code> maintains the order of keys as they were inserted.</p>
        <pre><code>from collections import OrderedDict

d = OrderedDict()
d['one'] = 1
d['two'] = 2</code></pre>

        <h2>4. Namedtuple</h2>
        <p><code>Namedtuple</code> creates a simple class with named fields, providing a more readable alternative to
            regular tuples.</p>
        <pre><code>from collections import namedtuple

Point = namedtuple('Point', ['x', 'y'])
p = Point(1, 2)</code></pre>

        <h2>5. Deque</h2>
        <p><code>Deque</code> (double-ended queue) supports efficient append and pop operations on both ends.</p>
        <pre><code>from collections import deque

d = deque([1, 2, 3])
d.append(4)
d.popleft()</code></pre>

        <h2>6. Heaps from heapq</h2>
        <p>The <code>heapq</code> module provides functions for heap operations. A heap is a binary tree-based data
            structure that maintains the heap property.</p>
        <pre><code>import heapq

heap = [3, 1, 4, 1, 5, 9, 2]
heapq.heapify(heap)   # Convert list into a heap
smallest = heapq.heappop(heap)</code></pre>

        <p>These advanced data structures offer specialized functionalities and performance improvements for various
            programming scenarios. Understanding and using them can lead to more efficient and organized code.</p>
        <h1>Advanced Topics in Python</h1>
        <p>Here are some advanced topics in Python that go beyond the basics:</p>

        <h2>1. Decorators</h2>
        <p>Decorators are functions that modify or enhance the behavior of other functions. They are often used for
            adding functionality like logging, authentication, or measuring execution time.</p>

        <h2>2. Generators</h2>
        <p>Generators are a memory-efficient way to create iterators. They allow you to iterate over large sequences
            without storing the entire sequence in memory at once.</p>

        <h2>3. Iterators and Iterables</h2>
        <p>Iterators are objects that implement the methods <code>__iter__()</code> and <code>__next__()</code>.
            Iterables are objects that can be iterated over, like lists or tuples.</p>

        <h2>4. Context Managers</h2>
        <p>Context managers, implemented using the <code>with</code> statement, allow you to manage resources and
            perform setup/teardown operations automatically, like opening/closing files.</p>

        <h2>5. Metaclasses</h2>
        <p>Metaclasses define the behavior of classes. They allow you to control how classes are created and provide a
            way to modify class behavior globally.</p>

        <h2>6. Concurrency and Multithreading</h2>
        <p>Python offers threading and multiprocessing libraries for handling concurrency. The <code>threading</code>
            module provides threads, while the <code>multiprocessing</code> module offers processes for parallel
            execution.</p>

        <h2>7. Coroutines and Asynchronous Programming</h2>
        <p>Coroutines are functions that can be paused and resumed. Asynchronous programming with the
            <code>asyncio</code> library allows you to write asynchronous, non-blocking code.</p>

        <h2>8. Memory Management</h2>
        <p>Understanding memory management in Python, including reference counting, garbage collection, and memory
            optimization techniques, can help improve performance.</p>

        <h2>9. Performance Optimization</h2>
        <p>Techniques like profiling, memory profiling, and using specialized libraries (like NumPy for numerical
            computations) can optimize your code for speed and efficiency.</p>

        <h2>10. Dynamic Typing and Type Annotations</h2>
        <p>Python's dynamic typing allows you to change the type of a variable during runtime. Type annotations and the
            <code>typing</code> module can help document and enforce type hints in your code.</p>

        <h2>11. Unicode and Internationalization</h2>
        <p>Python supports Unicode natively, making it suitable for working with text in various languages and character
            encodings.</p>

        <h2>12. C Extensions and Cython</h2>
        <p>Python can be extended with C/C++ libraries and modules for performance-critical tasks. Cython is a tool that
            allows you to write C-like code and compile it to Python extensions.</p>

        <p>These advanced topics provide a deeper understanding of Python's capabilities and allow you to write more
            efficient, robust, and versatile code.</p>
    </div>
</body>

</html>



























































































































































































































<!DOCTYPE html>
<html>

<head>
    <title>C Extensions and Cython</title>
</head>

<body>
    <p>
    <h5>C Extensions and Cython</h5>
    <p>C Extensions and Cython are techniques used in Python to optimize performance by integrating C or C++ code
        into
        Python programs. These techniques allow you to write low-level code that can be compiled and executed
        alongside
        Python code, achieving significant speed improvements for CPU-bound operations.</p>

    <h6>1. C Extensions</h6>
    <p>C extensions involve writing C code that is compiled into a shared library (.so on Unix-like systems, .dll on
        Windows) that can be imported and used like any other Python module. This technique is useful for maximizing
        performance in critical sections of code.</p>
    <ul>
        <li>Write C code and create a Python-compatible extension module.</li>
        <li>Compile the C code using tools like <code>distutils</code>, <code>setuptools</code>, or manually using a
            C
            compiler.</li>
    </ul>

    <h6>2. Cython</h6>
    <p>Cython is a programming language that makes it easy to write C extensions for Python, using a Python-like
        syntax.
        It allows you to write high-level Python code while achieving the performance of C. Cython code is
        translated
        into C code, which is then compiled into a shared library.</p>
    <ul>
        <li>Write Cython code using <code>.pyx</code> files.</li>
        <li>Use Cython's annotations and features to optimize specific sections of code.</li>
        <li>Compile Cython code into a C extension using the <code>cythonize</code> tool.</li>
    </ul>

    <h6>3. Benefits</h6>
    <ul>
        <li><strong>Performance:</strong> C extensions and Cython provide performance improvements for CPU-bound
            tasks
            by avoiding Python's interpreter overhead.</li>
        <li><strong>Low-Level Control:</strong> C extensions and Cython allow you to write low-level code to
            interact
            directly with memory and hardware.</li>
        <li><strong>Existing Libraries:</strong> You can easily use existing C or C++ libraries from Python,
            enhancing
            your program's capabilities.</li>
    </ul>

    <h6>4. Drawbacks</h6>
    <ul>
        <li><strong>Complexity:</strong> Writing and maintaining C code can be more complex than pure Python code.
        </li>
        <li><strong>Platform-Specific:</strong> C extensions might require recompilation for different platforms.
        </li>
        <li><strong>Debugging:</strong> Debugging C code can be more challenging than debugging Python.</li>
    </ul>

    <h6>5. Example (Cython)</h6>
    <p>Here's a simple example of using Cython to speed up a function:</p>
    <p><strong>Python version:</strong></p>
    <pre><code>def calculate_sum(n):
    total = 0
    for i in range(n):
        total += i
    return total</code></pre>
    <p><strong>Cython version (in <code>my_module.pyx</code>):</strong></p>
    <pre><code>def calculate_sum(int n):
    cdef int total = 0
    for i in range(n):
        total += i
    return total</code></pre>
    <p>Compile Cython code:</p>
    <pre><code>cythonize -i my_module.pyx</code></pre>

    <h6>6. When to Use</h6>
    <ul>
        <li>Use C extensions or Cython when you've identified specific bottlenecks that require low-level
            optimizations.
        </li>
        <li>For general-purpose Python code, the overhead of writing and maintaining C extensions might outweigh the
            performance gains.</li>
    </ul>

    <p>Both C extensions and Cython provide ways to bridge the gap between Python's high-level expressiveness and
        the
        performance of lower-level languages. Choose the technique that best fits your use case and consider the
        trade-offs between performance gains and development complexity.</p>
    </p>
</body>

</html>
